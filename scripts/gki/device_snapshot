#! /bin/sh
# SPDX-License-Identifier: GPL-2.0
#
# (c) 2019, Google

progname=${0##*/}
NUM=XX
USAGE="USAGE: ${progname} [-s <serialno>] [-f [<input>]] [-o <output>]

Collect filtered /dev and /sys details, along with dmesg and probe list.

if <output> is empty ('' or last option), will not collect dmesg or probe
list.  If no -o option is specified, then <output> will be default of -
(stdout) and all pieces will go to the standard output separated by a snip
header.  If specified, <output> will contain the filtered /dev/ and /sys/
dumps, <output>.probed the subset filter of just the probed drivers,
<output>.dmesg the kernel logs and <output>.config the uncompressed
/proc/config.gz.

NB: for default standard output, the probed list will be post-filter so
    some details may be altered to make it easier to discover differences.
    So if bus enumerations change, some of the enumerators will be replaced
    with an '${NUM}' so that they continue to match when moved.  For a specified
    output, the <output>.probed file will retain the details.

-f <input> allows one to utilize the filter to an existing find /dev /sys
output from a device.  No dmesg will be collected.

-s <serialno> will allow one to specify a device to connect to when multiples
are available, otherwise will default to one available or ANDROID_SERIAL
environment variable."

EMPTY=""
SPACE=" "
# A _real_ embedded tab character
TAB="`echo | tr '\n' '\t'`"
# A _real_ embedded carriage return character
CR="`echo | tr '\n' '\r'`"

##
##  Helper Functions
##

[ "USAGE: inFastboot

Returns: true if device is in fastboot mode" ]
inFastboot() {
  fastboot devices |
    if [ -n "${ANDROID_SERIAL}" ]; then
      grep "^${ANDROID_SERIAL}[${SPACE}${TAB}]" > /dev/null
    else
      wc -l | grep '^1$' >/dev/null
    fi
}


[ "USAGE: inAdb

Returns: true if device is in adb mode" ]
inAdb() {
  adb devices </dev/null |
    grep -v -e 'List of devices attached' -e '^$' -e "[${SPACE}${TAB}]recovery\$" |
    if [ -n "${ANDROID_SERIAL}" ]; then
      grep "^${ANDROID_SERIAL}[${SPACE}${TAB}]" > /dev/null
    else
      wc -l | grep '^1$' >/dev/null
    fi
}

[ "USAGE: inRecovery

Returns: true if device is in recovery mode" ]
inRecovery() {
  local list="`adb devices |
              grep -v -e 'List of devices attached' -e '^$'`"
  if [ -n "${ANDROID_SERIAL}" ]; then
    echo "${list}" |
      grep "^${ANDROID_SERIAL}[${SPACE}${TAB}][${SPACE}${TAB}]*recovery\$" >/dev/null
    return ${?}
  fi
  if echo "${list}" | wc -l | grep '^1$' >/dev/null; then
    echo "${list}" |
      grep "[${SPACE}${TAB}]recovery\$" >/dev/null
    return ${?}
  fi
  false
}

[ "USAGE: USB_DEVICE=\`usb_devnum [--next]\`

USB_DEVICE contains cache. Update if system changes.

Returns: the devnum for the USB_SERIAL device" ]
usb_devnum() {
  if [ -n "${USB_SERIAL}" ]; then
    local usb_device=`cat ${USB_SERIAL%/serial}/devnum 2>/dev/null | tr -d ' \t\r\n'`
    if [ -n "${usb_device}" ]; then
      USB_DEVICE=dev${usb_device}
    elif [ -n "${USB_DEVICE}" -a "${1}" ]; then
      USB_DEVICE=dev`expr ${USB_DEVICE#dev} + 1`
    fi
    echo "${USB_DEVICE}"
  fi
}

[ "USAGE: format_duration [<seconds>|<seconds>s|<minutes>m|<hours>h|<days>d]

human readable output whole seconds, whole minutes or mm:ss" ]
format_duration() {
  if [ -z "${1}" ]; then
    echo unknown
    return
  fi
  local duration="${1}"
  if [ X"${duration}" != X"${duration%s}" ]; then
    duration=${duration%s}
  elif [ X"${duration}" != X"${duration%m}" ]; then
    duration=`expr ${duration%m} \* 60`
  elif [ X"${duration}" != X"${duration%h}" ]; then
    duration=`expr ${duration%h} \* 3600`
  elif [ X"${duration}" != X"${duration%d}" ]; then
    duration=`expr ${duration%d} \* 86400`
  fi
  local seconds=`expr ${duration} % 60`
  local minutes=`expr \( ${duration} / 60 \) % 60`
  local hours=`expr ${duration} / 3600`
  if [ 0 -eq ${minutes} -a 0 -eq ${hours} ]; then
    if [ 1 -eq ${duration} ]; then
      echo 1 second
      return
    fi
    echo ${duration} seconds
    return
  elif [ 60 -eq ${duration} ]; then
    echo 1 minute
    return
  elif [ 0 -eq ${seconds} -a 0 -eq ${hours} ]; then
    echo ${minutes} minutes
    return
  fi
  if [ 0 -eq ${hours} ]; then
    echo ${minutes}:`expr ${seconds} / 10``expr ${seconds} % 10`
    return
  fi
  echo ${hours}:`expr ${minutes} / 10``expr ${minutes} % 10`:`expr ${seconds} / 10``expr ${seconds} % 10`
}

[ "USAGE: adb_wait [timeout]

Returns: waits until the device has returned for adb or optional timeout" ]
adb_wait() {
  local start=`date +%s`
  local duration=
  local ret
  if [ -n "${1}" ]; then
    USB_DEVICE=`usb_devnum --next`
    duration=`format_duration ${1}`
    echo -n ". . . waiting ${duration}" ${ANDROID_SERIAL} ${USB_ADDRESS} ${USB_DEVICE} "${CR}"
    timeout --preserve-status --signal=KILL ${1} adb wait-for-device 2>/dev/null
    ret=${?}
    echo -n "                                                                             ${CR}"
  else
    adb wait-for-device
    ret=${?}
  fi
  USB_DEVICE=`usb_devnum`
  if [ 0 = ${ret} -a -n "${ACTIVE_SLOT}" ]; then
    local active_slot=`get_active_slot`
    if [ X"${ACTIVE_SLOT}" != X"${active_slot}" ]; then
      echo "${ORANGE}[  WARNING ]${NORMAL} Active slot changed from ${ACTIVE_SLOT} to ${active_slot}" >&2
    fi
  fi
  local end=`date +%s`
  local diff_time=`expr ${end} - ${start}`
  local _print_time=${print_time}
  if [ ${diff_time} -lt 15 ]; then
    _print_time=false
  fi
  diff_time=`format_duration ${diff_time}`
  if [ "${diff_time}" = "${duration}" ]; then
    _print_time=false
  fi

  local reason=
  if inAdb; then
    reason=`get_property ro.boot.bootreason`
  fi
  case ${reason} in
    reboot*)
      reason=
      ;;
    ${EMPTY})
      ;;
    *)
      reason=" for boot reason ${reason}"
      ;;
  esac
  if ${_print_time} || [ -n "${reason}" ]; then
    echo "${BLUE}[     INFO ]${NORMAL} adb wait duration ${diff_time}${reason}"
  fi >&2

  return ${ret}
}

[ "USAGE: fastboot_wait [timeout]

Returns: waits until the device has returned for fastboot or optional timeout" ]
fastboot_wait() {
  local ret
  # fastboot has no wait-for-device, but it does an automatic
  # wait and requires (even a nonsensical) command to do so.
  if [ -n "${1}" ]; then
    USB_DEVICE=`usb_devnum --next`
    echo -n ". . . waiting `format_duration ${1}`" ${ANDROID_SERIAL} ${USB_ADDRESS} ${USB_DEVICE} "${CR}"
    timeout --preserve-status --signal=KILL ${1} fastboot wait-for-device >/dev/null 2>/dev/null
    ret=${?}
    echo -n "                                                                             ${CR}"
    ( exit ${ret} )
  else
    fastboot wait-for-device >/dev/null 2>/dev/null
  fi ||
    inFastboot
  ret=${?}
  USB_DEVICE=`usb_devnum`
  if [ 0 = ${ret} -a -n "${ACTIVE_SLOT}" ]; then
    local active_slot=`get_active_slot`
    if [ X"${ACTIVE_SLOT}" != X"${active_slot}" ]; then
      echo "${ORANGE}[  WARNING ]${NORMAL} Active slot changed from ${ACTIVE_SLOT} to ${active_slot}"
    fi >&2
  fi
  return ${ret}
}

[ "USAGE: recovery_wait [timeout]

Returns: waits until the device has returned for recovery or optional timeout" ]
recovery_wait() {
  local ret
  if [ -n "${1}" ]; then
    USB_DEVICE=`usb_devnum --next`
    echo -n ". . . waiting `format_duration ${1}`" ${ANDROID_SERIAL} ${USB_ADDRESS} ${USB_DEVICE} "${CR}"
    timeout --preserve-status --signal=KILL ${1} adb wait-for-recovery 2>/dev/null
    ret=${?}
    echo -n "                                                                             ${CR}"
  else
    adb wait-for-recovery
    ret=${?}
  fi
  USB_DEVICE=`usb_devnum`
  if [ 0 = ${ret} -a -n "${ACTIVE_SLOT}" ]; then
    local active_slot=`get_active_slot`
    if [ X"${ACTIVE_SLOT}" != X"${active_slot}" ]; then
      echo "${ORANGE}[  WARNING ]${NORMAL} Active slot changed from ${ACTIVE_SLOT} to ${active_slot}"
    fi >&2
  fi
  return ${ret}
}

[ "any_wait [timeout]

Returns: waits until a device has returned or optional timeout" ]
any_wait() {
  (
    adb_wait ${1} &
    adb_pid=${!}
    fastboot_wait ${1} &
    fastboot_pid=${!}
    recovery_wait ${1} &
    recovery_pid=${!}
    wait -n
    kill "${adb_pid}" "${fastboot_pid}" "${recovery_pid}"
  ) >/dev/null 2>/dev/null
  inFastboot || inAdb || inRecovery
}

##
##  RUNTIME
##

filter=
output=-
while [ ${#} -gt 0 ]; do
  case ${1} in
    -f=* | --filter=*)
      filter=${1#-f=}
      filter=${filter#--filter=}
      ;;
    -f | --filter)
      if [ ${#} = 1 -o -z "${2}" ]; then
        filter=-
      else
        shift
        filter=${1}
      fi
      ;;
    -h | -\? | --help)
      echo "${USAGE}"
      exit 0
      ;;
    -o=* | --output=*)
      output=${1#-o=}
      output=${output#--output=}
      ;;
    -o | --output)
      if [ ${#} = 1 -o -z "${2}" ]; then
        # empty output results in no dmesg or probed collection
        output=
      else
        shift
        output=${1}
      fi
      ;;
    -s=* | --serial=*)
      ANDROID_SERIAL=${1#-s=}
      export ANDROID_SERIAL=${ANDROID_SERIAL#--serial=}
      ;;
    -s | --serial)
      shift
      export ANDROID_SERIAL=${1}
      ;;
    *)
      echo "unknown parm ${1}"
      echo "${USAGE}"
      exit 1
      ;;
  esac
  shift
done

USB_SERIAL=
[ -z "${ANDROID_SERIAL}" ] || USB_SERIAL=`find /sys/devices -name serial |
                                          grep usb |
                                          xargs grep -l ${ANDROID_SERIAL}`
USB_ADDRESS=
if [ -n "${USB_SERIAL}" ]; then
  USB_ADDRESS=${USB_SERIAL%/serial}
  USB_ADDRESS=usb${USB_ADDRESS##*/}
fi

if [ -z "${filter}" ]; then
  if inFastboot; then
    echo ERROR: in fastboot mode >&2
    exit 1
  fi
  if inRecovery; then
    echo ERROR: in recovery mode >&2
    exit 1
  fi
  if ! inAdb; then
    any_wait 2m
    if [ -n "${ANDROID_SERIAL}" ]; then
      echo ERROR: not in adb mode >&2
      exit 1
    fi
    COUNT=`adb devices </dev/null |
             grep -v -e 'List of devices attached' -e '^$' |
             wc -l`
    echo ERROR: ${COUNT} devices attached >&2
    exit 1
  fi
fi

if [ -n "${filter}" ]; then
  cat ${filter}
else
  adb shell su root find /dev /sys </dev/null 2>/dev/null |
  if [ -n "${output}" -a X"${output}" != X"-" ]; then
    tee /proc/self/fd/99 |
      sed -n 's@/sys/devices/platform/\(.*\)/driver$@\1@p' |
      sort -u >${output}.probed
    adb shell su root dmesg </dev/null >${output}.dmesg
    adb shell su root cat /proc/config.gz </dev/null | gunzip >${output}.config
  else
    cat - >&99
  fi 99>&1
fi |
  grep -v '^\(/dev/ashmem\|/dev/block/mapper/by-uuid/\|/dev/fscklogs/log\)' |
  grep -v '^\(/dev/socket/location/socket_hal\|/sys/class/hwmon/\)' |
  grep -v '^/dev/socket/netmgr/netmgr_connect_socket$' |
  grep -v '^/dev/socket/qdma/qdma-campmgr-s$' |
  grep -v '^/dev/socket/qmux_radio/' |
  grep -v '^/sys/dev/char/[0-9]*:[0-9]*$' |
  grep -v '^/sys/devices/virtual/thermal/tz-by-name/wsatz[.][0-9]*$' |
  grep -v '^/sys/kernel/debug/tracing/instances/wifi' |
  sed "s@\(/regulator[.]\)[0-9][0-9]*\$@\1${NUM}@
       s@\(/regulator[.]\)[0-9][0-9]*/@\1${NUM}/@g
       s@\(/vppservice_\)[0-9][0-9]*\$@\1${NUM}@
       s@\(/msi_irqs/\)[0-9][0-9]*\$@\1${NUM}@
       s@\(/sys/class\|/sys/devices/platform/soc/[0-9a-f]*[.]qcom,gpi-dma\)\(/dma/dma\)[0-9]*\(chan[0-9]*\(\|/.*\)\)\$@\1\2${NUM}\3@
       s@\(/i2c-\)\([0-9]\)\(/[^/]*/i2c-\)\2\(\|/.*\)\$@\1${NUM}\3${NUM}\4@
       s@\(/i2c-\)[0-9]\(\|/[^/]*\)\$@\1${NUM}\2@
       s@-\([0-9]\)/\1\(-[0-9][0-9][0-9][0-9]/\)@-${NUM}/${NUM}\2@g
       s@/[0-9]\(-[0-9][0-9][0-9][0-9]\(\|-vdd\|-vdd/.*\|-avdd\|-avdd/.*\|-vio\|-vio/.*\|/.*\)\)\$@${NUM}\1@
       s@\(/sys/devices/platform/soc/[0-9a-z]*[.]qcom,[^/]*/subsys\)[0-9][0-9]*@\1${NUM}@
       s@\(rpmsg_chrdev[.]0[.]0/rpmsg/rpmsg_ctrl\)[0-9][0-9]*@\1${NUM}@
       s@\(/sys/devices/virtual/kgsl/kgsl/pagetables/\)[0-9][0-9]*@\1${NUM}@
       s@\(/sys/devices/virtual/kgsl/kgsl/proc/\)[0-9][0-9]*@\1${NUM}@
       s@\(/sys/kernel/debug/adsprpc/\(adsp\|cdsp\|ssc\)rpcd_\)[0-9][0-9]*\$@\1${NUM}@
       s@\(/sys/kernel/debug/binder/proc/\)[0-9][0-9]*\$@\1${NUM}@
       s@\(/sys/kernel/debug/kgsl/proc/\)[0-9][0-9]*@\1${NUM}@
       s@\(/sys/kernel/debug/msm_cvp/core0/inst_\)[0-9a-f][0-9a-f]*@\1${NUM}@
       s@\(/sys/kernel/iommu_groups/\)[0-9][0-9]*@\1${NUM}@
       s@\(/devices/soc:qcom,msm_fastrpc:qcom,msm_fastrpc_compute_cb\)[0-9][0-9]*@\1${NUM}@
       s@\(/sys/kernel/irq/\)[0-9][0-9]*@\1${NUM}@" |
  if [ -n "${output}" -a X"${output}" != X"-" ]; then
    sort -u >${output}
  else
    TMP=`mktemp -d`
    if [ X"${output}" = X"-" ]; then
      echo "------------------------> cut dump < ------------------------"
      sort -u |
      tee /proc/self/fd/99 |
        sed -n 's@/sys/devices/platform/\(.*\)/driver$@\1@p' >${TMP}/probed
    else
      sort -u >&99
    fi 99>&1
    if [ -s "${TMP}/probed" ]; then
      echo "-----------------------> cut probed <------------------------"
      cat ${TMP}/probed
    fi
    rm -rf ${TMP}
  fi
if [ -z "${filter}" -a X"${output}" = X"-" ]; then
  echo "------------------------> cut dmesg <------------------------"
  adb shell su root dmesg </dev/null
  echo "-----------------------> cut .config <-----------------------"
  adb shell su root cat /proc/config.gz </dev/null | gunzip
fi
