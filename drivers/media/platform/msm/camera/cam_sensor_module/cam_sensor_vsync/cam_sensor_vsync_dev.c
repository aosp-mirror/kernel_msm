/* Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/debugfs.h>
#include <linux/device.h>
#include <linux/platform_device.h>
#include <media/cam_req_mgr.h>
#include "cam_req_mgr_dev.h"
#include "cam_debug_util.h"
#include "cam_sensor_vsync.h"
#include "cam_sensor_core.h"
#include "cam_sensor_util.h"
#include "cam_soc_util.h"
#include "cam_trace.h"
#include "cam_common_util.h"
#include <linux/qrtr.h>
#include <linux/net.h>
#include <linux/completion.h>
#include <linux/idr.h>
#include <linux/string.h>
#include <net/sock.h>
#include <linux/soc/qcom/qmi.h>


struct vsync_ctx_type {
	struct qmi_handle qmi;
	struct workqueue_struct *work_queue;
	struct list_head pending_reqs;
	struct mutex  list_lock;
	struct dentry *de_dir;
	struct dentry *de_data;
};

struct cam_vsync_work_payload {
	struct vsync_ctx_type *ctx;
	struct cam_req_mgr_message req_msg;
	struct work_struct work;
};

struct cam_vsync_req_msg_v01 {
	uint32_t data_len;
	uint8_t data[CAM_VSYNC_DATA_SIZE_V01];

	/* Optional */
	/**< Must be set to true if use_jumbo_report is being passed */
	uint8_t use_jumbo_report_valid;
	uint8_t use_jumbo_report;
};

static struct qmi_elem_info cam_vsync_req_msg_v01_ei[] = {
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_REQ1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_req_msg_v01,
					   data_len),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= CAM_VSYNC_DATA_SIZE_V01,
		.elem_size	= sizeof(uint8_t),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= CAM_VSYNC_REQ1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_req_msg_v01,
					   data),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_req_msg_v01,
					   use_jumbo_report_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_req_msg_v01,
					   use_jumbo_report),
	},
	{}
};

struct cam_vsync_resp_msg_v01 {

	/* Mandatory */
	struct qmi_response_type_v01 resp;

	/* Optional */
	/* Must be set to true if client_id is being passed */
	uint8_t client_id_valid;
	uint64_t client_id;
	/*  Client ID identifies the client connection. */
	/*  Generated by service, and returned in all */
	/*  sns_client_report_ind_msg.  Will be the same value in all */
	/*  sns_client_resp_msg/sns_client_report_ind_msg for */
	/*  this client connection. */

	/* Optional */
	/* Must be set to true if result is being passed */
	uint8_t result_valid;
	uint32_t result;
	/* Result status of the request; see sns_pb_error_type */
};/* Message */


static struct qmi_elem_info cam_vsync_resp_msg_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_RESP1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_resp_msg_v01,
					   resp),
		.ei_array	= qmi_response_type_v01_ei,
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_resp_msg_v01,
						client_id_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(u64),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_resp_msg_v01,
						client_id),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT2_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_resp_msg_v01,
					   result_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT2_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_resp_msg_v01,
					   result),
	},
	{}
};

/** Indication Message; Report containing one or more Sensor-generated events */
struct sns_client_report_ind_msg_v01 {
	/* Mandatory */
	uint64_t client_id;
	/**<   Client ID identifies the client connection.  */

	/* Mandatory */
	uint32_t payload_len; /**< Must be set to # of elements in payload */
	uint8_t payload[SNS_CLIENT_REPORT_LEN_MAX_V01];
};

/** Indication Message; Report containing one or more Sensor-generated events */
struct sns_client_jumbo_report_ind_msg_v01 {
	/* Mandatory */
	uint64_t client_id;
	/**<   Client ID identifies the client connection.  */

	/* Mandatory */
	uint32_t payload_len; /**< Must be set to # of elements in payload */
	uint8_t payload[SNS_CLIENT_JUMBO_REPORT_LEN_MAX_V01];
};

static struct qmi_elem_info sns_client_report_ind_msg_v01_ei[] = {
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint64_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_IND1_TLV_TYPE,
		.offset		= offsetof(struct sns_client_report_ind_msg_v01,
						client_id),
	},
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_IND2_TLV_TYPE,
		.offset		= offsetof(struct sns_client_report_ind_msg_v01,
					   payload_len),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= SNS_CLIENT_REPORT_LEN_MAX_V01,
		.elem_size	= sizeof(uint8_t),
		.is_array	= STATIC_ARRAY,
		.tlv_type	= CAM_VSYNC_IND2_TLV_TYPE,
		.offset		= offsetof(struct sns_client_report_ind_msg_v01,
					   payload),
	},
	{
		.data_type  = QMI_EOTI,
		.is_array   = NO_ARRAY,
		.tlv_type   = QMI_COMMON_TLV_TYPE,
	}
};

static struct vsync_ctx_type cam_vsync_ctx;
static void cam_vsync_qmi_work(struct work_struct *work);

static int cam_send_request_qmi(
	struct qmi_handle *qmi,
	struct cam_vsync_req_msg_v01 *req,
	struct cam_vsync_resp_msg_v01 *resp)
{
	int ret = 0;
	struct qmi_txn txn;

	ret = qmi_txn_init(qmi, &txn, cam_vsync_resp_msg_v01_ei, resp);
	if (ret < 0) {
		CAM_ERR(CAM_SENSOR, "%s:qmi_txn_init failed. %d", ret);
		goto out;
	}

	ret = qmi_send_request(qmi, NULL, &txn,
				CAM_VSYNC_REQ_MSG_ID_V01,
				sizeof(struct cam_vsync_req_msg_v01),
				cam_vsync_req_msg_v01_ei,
				req);
	if (ret < 0) {
		CAM_ERR(CAM_SENSOR, "%s:qmi_send_request failed. %d", ret);
		qmi_txn_cancel(&txn);
		goto out;
	}

	ret = qmi_txn_wait(&txn, 5 * HZ);
	if (ret < 0) {
		CAM_ERR(CAM_SENSOR, "%s:qmi_txn_wait failed. %d", ret);
		goto out;
	}

	CAM_DBG(CAM_SENSOR, "Received Resp result = %d, err = %d",
		resp->resp.result,
		resp->resp.error);
	ret = resp->resp.result;

out:
	return ret;
}

static int cam_send_vsync_packet_qmi(struct qmi_handle *qmi,
			struct cam_sensor_vsync_packet *packet)
{
	struct cam_vsync_resp_msg_v01 *resp;
	struct cam_vsync_req_msg_v01 *req;
	int ret = 0;

	if (!packet) {
		CAM_ERR(CAM_SENSOR, "%s: packet is NULL", __func__);
		return -EINVAL;
	}

	if (!qmi) {
		CAM_ERR(CAM_SENSOR, "%s: QMI handle is NULL", __func__);
		return -EINVAL;
	}

	req = kzalloc(sizeof(*req), GFP_KERNEL);
	if (!req)
		return -ENOMEM;

	resp = kzalloc(sizeof(*resp), GFP_KERNEL);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}

	cam_vsync_make_sensor_request(packet, req->data, &req->data_len);
	req->use_jumbo_report_valid = false;

	CAM_DBG(CAM_SENSOR,
			"Notify camera:%d, frame_id:%d, timestamp:%lld",
			packet->cam_id,
			packet->frame_id,
			packet->timestamp);

	ret = cam_send_request_qmi(qmi, req, resp);
	if (ret < 0)
		goto out;

	if (packet->frame_id <= 1) {
		CAM_DBG(CAM_SENSOR, "Send vsync config request!");
		cam_vsync_make_config_request(packet->cam_id,
			req->data,
			&req->data_len);
		req->use_jumbo_report_valid = false;
		ret = cam_send_request_qmi(qmi, req, resp);
	}

out:
	kfree(resp);
	kfree(req);

	return ret;
}

static int cam_vsync_add_pending_req(struct cam_req_mgr_message *msg)
{
	struct cam_sensor_vsync_req *vsync_req;
	struct vsync_ctx_type *ctx = &cam_vsync_ctx;

	vsync_req = kzalloc(sizeof(struct cam_sensor_vsync_req), GFP_ATOMIC);
	if (!vsync_req)
		return -EINVAL;
	memcpy(&vsync_req->req_message, msg, sizeof(*msg));
	mutex_lock(&ctx->list_lock);
	list_add(&vsync_req->list, &ctx->pending_reqs);
	mutex_unlock(&ctx->list_lock);

	return 0;
}

static int cam_vsync_get_cam_id(int32_t link_hdl, uint32_t *cam_id)
{
	struct cam_req_mgr_core_link *link;
	struct cam_req_mgr_connected_device *dev = NULL;
	struct cam_sensor_ctrl_t *s_ctrl = NULL;
	uint32_t sensor_id = 0;
	int i, rc = 0;

	link = (struct cam_req_mgr_core_link *)
		cam_get_device_priv(link_hdl);
	if (!link) {
		CAM_DBG(CAM_SENSOR, "link ptr NULL %x",
			link_hdl);
		return -EINVAL;
	}

	for (i = 0; i < link->num_devs; i++) {
		dev = &link->l_dev[i];
		if (!dev)
			continue;
		if (dev->dev_info.dev_id != CAM_REQ_MGR_DEVICE_SENSOR)
			continue;
		s_ctrl = (struct cam_sensor_ctrl_t *)
			cam_get_device_priv(dev->dev_info.dev_hdl);

		if (!s_ctrl) {
			CAM_ERR(CAM_SENSOR, "Device data is NULL");
			return -EINVAL;
		}
		/* Kernel    REAR_WIDE REAR_TELE FRONT_CAM */
		/* Userspace REAR_WIDE FRONT_CAM REAR_TELE */
		sensor_id = s_ctrl->soc_info.index;
		switch (sensor_id) {
		case 0:
			*cam_id = 0;
			break;
		case 1:
			*cam_id = 2;
			break;
		case 2:
			*cam_id = 1;
			break;
		default:
			break;
		}
	}

	return rc;
}

int cam_notify_vsync_qmi(struct cam_req_mgr_message *msg)
{
	struct cam_vsync_work_payload *payload;
	bool work_status;
	int rc = 0;

	if (!msg) {
		CAM_ERR(CAM_CRM, "msg is NULL");
		return -EINVAL;
	}

	payload = kzalloc(sizeof(struct cam_vsync_work_payload), GFP_ATOMIC);
	if (!payload) {
		rc = -ENOMEM;
	} else {
		payload->ctx = &cam_vsync_ctx;
		memcpy(&payload->req_msg, msg, sizeof(*msg));
		INIT_WORK((struct work_struct *)&payload->work,
			cam_vsync_qmi_work);
		work_status = queue_work(cam_vsync_ctx.work_queue,
				&payload->work);
		if (work_status == false) {
			CAM_ERR(CAM_SENSOR, "Failed to queue work");
			kfree(payload);
			rc = -EINVAL;
		}
	}
	return rc;
}
EXPORT_SYMBOL(cam_notify_vsync_qmi);

static void cam_vsync_qmi_work(struct work_struct *work)
{
	struct cam_vsync_work_payload *payload;
	struct vsync_ctx_type *ctx;
	struct qmi_handle *qmi;
	struct cam_req_mgr_message *msg;
	struct cam_sensor_vsync_packet packet;
	uint32_t cam_id;
	int rc;

	if (!work) {
		CAM_ERR(CAM_SENSOR, "Null work\n");
		return;
	}

	payload = container_of(work, struct cam_vsync_work_payload, work);
	if (!payload) {
		CAM_ERR(CAM_SENSOR, "Null payload\n");
		return;
	}

	ctx = payload->ctx;
	if (!ctx) {
		CAM_ERR(CAM_SENSOR, "Null ctx\n");
		goto out;
	}
	qmi = &ctx->qmi;
	msg = &payload->req_msg;
	if (!msg) {
		CAM_ERR(CAM_SENSOR, "Null msg\n");
		goto out;
	}

	rc = cam_vsync_get_cam_id(msg->u.frame_msg.link_hdl, &cam_id);
	if (rc < 0) {
		CAM_ERR(CAM_SENSOR, "Can't get camera id\n");
		goto out;
	}

	rc = cam_vsync_add_pending_req(msg);
	if (rc < 0) {
		CAM_ERR(CAM_SENSOR, "Can't add pending req\n");
		goto out;
	}

	if (!msg->u.frame_msg.sof_status) {
		packet.cam_id = cam_id;
		packet.frame_id = msg->u.frame_msg.frame_id;
		packet.timestamp = msg->u.frame_msg.timestamp;

		rc = cam_send_vsync_packet_qmi(qmi, &packet);
		if (rc < 0)
			CAM_ERR(CAM_SENSOR, "Failed to send vsync. %d\n", rc);
	}
out:
	/* Free the payload packet after use */
	kfree(payload);
}

static int cam_vsync_read(void *data, u64 *val)
{
	*val = 0;
	return 0;
}

static int cam_vsync_write(void *data, u64 val)
{
	struct vsync_ctx_type *ctx = &cam_vsync_ctx;
	struct qmi_handle *qmi = &ctx->qmi;
	struct cam_sensor_vsync_packet packet;
	int ret;

	packet.cam_id = 0;
	packet.frame_id = 0;
	packet.timestamp = val;
	ret = cam_send_vsync_packet_qmi(qmi, &packet);

	return ret;
}

static void vsync_event_cb(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,
			 struct qmi_txn *txn, const void *data)
{
	const struct sns_client_report_ind_msg_v01 *ind_msg = data;
	struct cam_sensor_vsync_result result;
	struct vsync_ctx_type *ctx = &cam_vsync_ctx;
	struct cam_sensor_vsync_req *vsync_req = NULL;
	struct cam_sensor_vsync_req *vsync_req_temp = NULL;
	struct cam_req_mgr_frame_msg *frame_msg = NULL;
	uint32_t cam_id;
	int rc;

	if (!ind_msg)
		return;

	rc = cam_vsync_parse_ind_message(
				(uint8_t *)ind_msg->payload,
				ind_msg->payload_len,
				&result);

	if (rc < 0) {
		CAM_ERR(CAM_SENSOR,
				"failed to parse QMI indication\n");
		return;
	}

	CAM_DBG(CAM_SENSOR, "cam_id=%d, frame_id=%d, sof=%lld, vsync =%lld",
			result.cam_id,
			result.frame_id,
			result.timestamp_sof,
			result.timestamp_vsync);

	list_for_each_entry_safe(vsync_req, vsync_req_temp,
			&ctx->pending_reqs, list) {
		frame_msg = &vsync_req->req_message.u.frame_msg;
		/* check if it is a stale link or old req*/
		if (!cam_get_device_priv(frame_msg->link_hdl) ||
			result.timestamp_sof - frame_msg->timestamp > 4) {
			/* remove from list */
			mutex_lock(&ctx->list_lock);
			list_del_init(&vsync_req->list);
			mutex_unlock(&ctx->list_lock);
			/* free memory */
			kfree(vsync_req);
			continue;
		}
		rc = cam_vsync_get_cam_id(frame_msg->link_hdl, &cam_id);
		CAM_DBG(CAM_SENSOR,
			"pending req cam_id=%d, frame_id=%d, sof=%lld",
			cam_id,
			frame_msg->frame_id,
			frame_msg->timestamp);
		if (rc == 0 &&
			cam_id == result.cam_id &&
			frame_msg->frame_id == result.frame_id &&
			frame_msg->timestamp == result.timestamp_sof) {
			/* Update with Vsync timestamp */
			frame_msg->timestamp == result.timestamp_vsync;
			if (cam_req_mgr_notify_message(&vsync_req->req_message,
				V4L_EVENT_CAM_REQ_MGR_VSYNC_TS,
				V4L_EVENT_CAM_REQ_MGR_EVENT))
				CAM_ERR(CAM_SENSOR,
					"Error in notifying the vsync time for req id:%lld",
					frame_msg->request_id);
			/* remove from list */
			mutex_lock(&ctx->list_lock);
			list_del_init(&vsync_req->list);
			mutex_unlock(&ctx->list_lock);
			/* free memory */
			kfree(vsync_req);
		}
	}
}

DEFINE_SIMPLE_ATTRIBUTE(cam_vsync_qmi_fops,
	cam_vsync_read,
	cam_vsync_write, "%16llu");

static struct dentry *cam_vsync_debug_dir;

static struct qmi_msg_handler cam_vsync_handlers[] = {
	{
		.type = QMI_INDICATION,
		.msg_id = CAM_VSYNC_REPORT_IND_V01,
		.ei = sns_client_report_ind_msg_v01_ei,
		.decoded_size = sizeof(struct sns_client_report_ind_msg_v01),
		.fn = vsync_event_cb
	},
	{}
};

static int cam_vsync_probe(struct platform_device *pdev)
{
	struct sockaddr_qrtr *sq;
	struct vsync_ctx_type *ctx = &cam_vsync_ctx;
	char path[20];
	int ret;

	ret = qmi_handle_init(&ctx->qmi, CAM_VSYNC_REQ_MAX_MSG_LEN_V01,
				NULL,
				cam_vsync_handlers);
	if (ret < 0)
		return ret;

	sq = dev_get_platdata(&pdev->dev);
	ret = kernel_connect(ctx->qmi.sock, (struct sockaddr *)sq,
				sizeof(*sq), 0);
	if (ret < 0) {
		CAM_ERR(CAM_SENSOR,
			"failed to connect to remote service port\n");
		goto err_release_qmi_handle;
	}

	snprintf(path, sizeof(path), "%d:%d", sq->sq_node, sq->sq_port);

	ctx->de_dir = debugfs_create_dir(path, cam_vsync_debug_dir);
	if (IS_ERR(ctx->de_dir)) {
		ret = PTR_ERR(ctx->de_dir);
		goto err_release_qmi_handle;
	}

	ctx->de_data = debugfs_create_file("data", 0600, ctx->de_dir,
						NULL, &cam_vsync_qmi_fops);
	if (IS_ERR(ctx->de_data)) {
		ret = PTR_ERR(ctx->de_data);
		goto err_remove_de_dir;
	}

	INIT_LIST_HEAD(&ctx->pending_reqs);
	mutex_init(&ctx->list_lock);
	platform_set_drvdata(pdev, ctx);

	return 0;

err_remove_de_dir:
	debugfs_remove(ctx->de_dir);
err_release_qmi_handle:
	qmi_handle_release(&ctx->qmi);

	return ret;
}

static int cam_vsync_remove(struct platform_device *pdev)
{
	struct vsync_ctx_type *ctx = platform_get_drvdata(pdev);
	struct cam_sensor_vsync_req *vsync_req = NULL;
	struct cam_sensor_vsync_req *vsync_req_temp = NULL;

	debugfs_remove(ctx->de_data);
	debugfs_remove(ctx->de_dir);

	qmi_handle_release(&ctx->qmi);
	mutex_lock(&ctx->list_lock);
	list_for_each_entry_safe(vsync_req, vsync_req_temp,
			&ctx->pending_reqs, list) {
		/* remove from list */
		list_del_init(&vsync_req->list);
		/* free memory */
		kfree(vsync_req);
	}
	mutex_unlock(&ctx->list_lock);
	mutex_destroy(&ctx->list_lock);

	return 0;
}

static struct platform_driver cam_vsync_driver = {
	.probe = cam_vsync_probe,
	.remove = cam_vsync_remove,
	.driver = {
		.name = "cam_vsync_client",
	},
};

static int cam_vsync_new_server(struct qmi_handle *qmi,
				 struct qmi_service *service)
{
	struct platform_device *pdev;
	struct sockaddr_qrtr sq = { AF_QIPCRTR, service->node, service->port };
	int ret;

	pdev = platform_device_alloc("cam_vsync_client", PLATFORM_DEVID_AUTO);
	if (!pdev)
		return -ENOMEM;

	ret = platform_device_add_data(pdev, &sq, sizeof(sq));
	if (ret)
		goto err_put_device;

	ret = platform_device_add(pdev);
	if (ret)
		goto err_put_device;

	service->priv = pdev;

	return 0;

err_put_device:
	platform_device_put(pdev);

	return ret;
}

static void cam_vsync_del_server(struct qmi_handle *qmi,
				  struct qmi_service *service)
{
	struct platform_device *pdev = service->priv;

	platform_device_unregister(pdev);
}

static struct qmi_handle lookup_client;

static struct qmi_ops lookup_ops = {
	.new_server = cam_vsync_new_server,
	.del_server = cam_vsync_del_server,
};

static int cam_vsync_init(void)
{
	int ret;

	cam_vsync_debug_dir = debugfs_create_dir("cam_vsync_qmi", NULL);
	if (IS_ERR(cam_vsync_debug_dir)) {
		CAM_ERR(CAM_SENSOR, "failed to create qmi_vsync dir\n");
		return PTR_ERR(cam_vsync_debug_dir);
	}

	ret = platform_driver_register(&cam_vsync_driver);
	if (ret)
		goto err_remove_debug_dir;

	ret = qmi_handle_init(&lookup_client, 0, &lookup_ops, NULL);
	if (ret < 0)
		goto err_unregister_driver;

	qmi_add_lookup(&lookup_client, SNS_CLIENT_SVC_ID_V01, 0, 0);

	cam_vsync_ctx.work_queue = alloc_workqueue("cam_vsync_client",
		WQ_UNBOUND | WQ_MEM_RECLAIM | WQ_SYSFS,
		CAM_VSYNC_INFLIGHT_WORKS);

	return 0;

err_unregister_driver:
	platform_driver_unregister(&cam_vsync_driver);
err_remove_debug_dir:
	debugfs_remove(cam_vsync_debug_dir);

	return ret;
}

static void cam_vsync_exit(void)
{
	flush_workqueue(cam_vsync_ctx.work_queue);
	destroy_workqueue(cam_vsync_ctx.work_queue);

	qmi_handle_release(&lookup_client);

	platform_driver_unregister(&cam_vsync_driver);

	debugfs_remove(cam_vsync_debug_dir);
}

module_init(cam_vsync_init);
module_exit(cam_vsync_exit);

MODULE_DESCRIPTION("Camera VSync QMI client driver");
MODULE_LICENSE("GPL v2");
